SELECT * FROM training.products;

SELECT
    product_name,
    AVG (price)
FROM
    training.products
INNER JOIN product_groups USING (group_id)
GROUP BY product_name;

SELECT
    product_name,
    price,
    group_name,
    AVG(price) OVER (
        PARTITION BY group_name
    )
FROM
    products
    INNER JOIN
        product_groups USING (group_id);

/*
Basic Syntax for a postgres window function:

window_function(arg1, arg2,..) OVER (
   [PARTITION BY partition_expression]
   [ORDER BY sort_expression [ASC | DESC] [NULLS {FIRST | LAST }])

window_function(arg1,arg2,...)
The window_function is the name of the window function. Some window functions do not accept any argument.

PARTITION BY clause
The PARTITION BY clause divides rows into multiple groups or partitions to which 
the window function is applied. Like the example above, we used the product group to divide the products 
into groups (or partitions).

The PARTITION BY clause is optional. If you skip the PARTITION BY clause, 
the window function will treat the whole result set as a single partition.

ORDER BY clause
The ORDER BY clause specifies the order of rows in each partition to which the window function is applied.

The ORDER BY clause uses the NULLS FIRST or NULLS LAST option to specify whether nullable values 
should be first or last in the result set. The default is NULLS LAST option.

 frame_clause
The frame_clause defines a subset of rows in the current partition to which the window function is applied. 
This subset of rows is called a frame.

Multiple windows:

SELECT
    wf1() OVER(PARTITION BY c1 ORDER BY c2),
    wf2() OVER(PARTITION BY c1 ORDER BY c2)
FROM table_name;

You can use the WINDOW clause to shorten the query as shown in the following query:

SELECT 
   wf1() OVER w,
   wf2() OVER w,
FROM table_name
WINDOW w AS (PARTITION BY c1 ORDER BY c2);

SELECT wf1() OVER w
FROM table_name 
WINDOW w AS (PARTITION BY c1 ORDER BY c2);

*/

SELECT
    product_name,
    group_name,
    price,
    ROW_NUMBER () OVER (
        PARTITION BY group_name
        ORDER BY
            price
    )
FROM
    products
INNER JOIN product_groups USING (group_id);

SELECT
	product_name,
	group_name,
  price,
	RANK () OVER (
		PARTITION BY group_name
		ORDER BY
			price
	)
FROM
	products
INNER JOIN product_groups USING (group_id);

SELECT
	product_name,
	group_name,
	price,
	DENSE_RANK () OVER (
		PARTITION BY group_name
		ORDER BY
			price
	)
FROM
	products
INNER JOIN product_groups USING (group_id);

SELECT
	product_name,
	group_name,
	price,
	FIRST_VALUE (price) OVER (
		PARTITION BY group_name
		ORDER BY
			price
	) AS lowest_price_per_group
FROM
	products
INNER JOIN product_groups USING (group_id);

SELECT
	product_name,
	group_name,
	price,
	LAST_VALUE (price) OVER (
		PARTITION BY group_name
		ORDER BY
			price RANGE BETWEEN UNBOUNDED PRECEDING
		AND UNBOUNDED FOLLOWING
	) AS highest_price_per_group
FROM
	products
INNER JOIN product_groups USING (group_id);

/*
The LAG() function has the ability to access data 
from the previous row, while the LEAD() function can access data from the next row.

LAG  (expression [,offset] [,default]) over_clause;
LEAD (expression [,offset] [,default]) over_clause;

In this syntax:

 expression – a column or expression to compute the returned value.
 offset – the number of rows preceding ( LAG)/ following ( LEAD) the current row. It defaults to 1.
 default – the default returned value if the offset goes beyond the scope of the window. The default is NULL if you skip it.
*/

SELECT
	product_name,
	group_name,
	price,
	LAG (price, 1) OVER (
		PARTITION BY group_name
		ORDER BY
			price
	) AS prev_price,
	price - LAG (price, 1) OVER (
		PARTITION BY group_name
		ORDER BY
			price
	) AS cur_prev_diff
FROM
	products
INNER JOIN product_groups USING (group_id);

